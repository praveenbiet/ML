<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-H">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dial-a-Neuron! (My First Perceptron)</title>
    <style>
        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #e0f7fa; /* Light cyan */
            color: #004d40; /* Dark teal */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            max-width: 1000px;
            width: 95%;
            background-color: #fff;
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 5px 20px rgba(0,77,64,0.2);
            border: 4px solid #00796b; /* Teal border */
        }
        h1, h2, h3 {
            color: #d84315; /* Deep orange */
            text-align: center;
        }
        .explanation {
            background-color: #fff3e0; /* Light orange */
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 6px solid #d84315;
            font-size: 0.98em;
        }
        .explanation strong { color: #00796b; }

        .main-layout {
            display: flex;
            justify-content: space-around;
            align-items: flex-start; /* Align tops */
            gap: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .input-panel, .weights-panel, .network-panel {
            background-color: #f1f8e9; /* Light green tint */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 2px dashed #7cb342; /* Lime green */
        }

        .input-panel { flex-basis: 250px; }
        .input-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            width: 150px;
            margin: 20px auto;
        }
        .input-cell {
            width: 60px;
            height: 60px;
            background-color: #e0e0e0; /* Grey */
            border: 2px solid #9e9e9e;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .input-cell.active {
            background-color: #a5d6a7; /* Light green */
            border-color: #4caf50; /* Green */
            font-weight: bold;
        }

        .weights-panel { flex-basis: 300px; }
        .weight-control {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .weight-control label {
            min-width: 80px;
            font-size: 0.9em;
        }
        .weight-control input[type="range"] {
            flex-grow: 1;
            cursor: pointer;
        }
        .weight-control .weight-value {
            min-width: 40px;
            text-align: right;
            font-weight: bold;
        }

        .network-panel {
            flex-grow: 1; /* Take remaining space */
            min-width: 350px; /* Minimum width */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .network-visualization {
            display: flex;
            justify-content: space-around;
            align-items: center;
            position: relative;
            width: 100%;
            min-height: 200px; /* Ensure space for SVG */
        }
        .neuron-vis {
            width: 80px;
            height: 80px;
            background-color: #ffc107; /* Amber */
            border: 3px solid #ffa000; /* Darker amber */
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            text-align: center;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.15);
            z-index: 1;
        }
        .neuron-vis.pulsing { animation: pulseEffect 0.6s ease-in-out; }
        @keyframes pulseEffect { /* Same pulse as before */
            0% { transform: scale(1); }
            50% { transform: scale(1.15); background-color: #ffecb3; box-shadow: 0px 0px 15px rgba(255,165,0,0.7);}
            100% { transform: scale(1); }
        }
        #output-neuron-vis .label { font-weight: bold; }

        .connections-svg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .connection-line { stroke: #00796b; stroke-width: 1.5; }
        .weight-display-svg { font-size: 0.7em; fill: #d84315; text-anchor: middle; }
        .anim-dot { fill: #ff6f00; opacity: 0; r: 5px; transition: r 0.1s, fill 0.1s;}

        .calculation-display { margin-top: 15px; font-size: 0.9em; text-align: center; width: 100%; }
        .output-display {
            text-align: center;
            font-size: 1.4em;
            margin-top: 20px; padding: 15px;
            background-color: #e0f2f1; border: 2px solid #00796b;
            border-radius: 10px;
        }
        .output-display span { font-weight: bold; font-size: 1.7em; }
        .output-display .prediction.yes { color: #388e3c; /* Green text */ }
        .output-display .prediction.no { color: #d32f2f; /* Red text */ }

        .controls { text-align: center; margin-top: 30px; }
        .controls button {
            padding: 12px 20px; background-color: #f4511e; /* Orange Red */
            color: white; border: none; border-radius: 8px; cursor: pointer;
            font-size: 1.1em; transition: background-color 0.2s;
        }
        .controls button:hover { background-color: #d84315; }
        .controls button:disabled { background-color: #bdbdbd; cursor: not-allowed; }
        
        .info-box {
            margin-top: 20px; padding: 10px; background-color: #eceff1; border-radius: 8px;
            font-size: 0.9em; border-left: 4px solid #546e7a;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Dial-a-Neuron! Our Little Pattern Spotter ðŸ§ ðŸ’¡</h1>
        <div class="explanation">
            <p>Hi Kids! Let's make a tiny brain cell (a <strong>Neuron</strong> or <strong>Perceptron</strong>) learn to spot a pattern! It's like the one in the video with switches and dials.</p>
            <ul>
                <li><strong>Input Grid:</strong> Click the squares to turn them ON (1, green) or OFF (0, grey). This is our pattern.</li>
                <li><strong>Weights (Dials):</strong> Use the sliders! These numbers tell our Neuron how important each input square is. Big positive numbers mean "Pay attention!", big negative numbers mean "Ignore this or do the opposite!".</li>
                <li><strong>Bias:</strong> This is the Neuron's own little starting mood. It adds this to its calculation.</li>
                <li>Our Goal: Make the Neuron say "YES!" (light up green, high number) when the <strong>TOP row is ON</strong> (1,1) and the <strong>BOTTOM row is OFF</strong> (0,0). For all other patterns, it should say "NO!" (light up red, low number).</li>
            </ul>
            <p>Press <strong>"Run Brain!"</strong> to see the messages flow and the Neuron decide! Can you find the right dial (weight) settings?</p>
        </div>

        <div class="main-layout">
            <div class="input-panel">
                <h2>1. Input Pattern</h2>
                <div class="input-grid" id="inputGrid">
                    <!-- Cells will be added by JS -->
                </div>
                <p style="text-align:center; font-size:0.9em;">Target: Top ON, Bottom OFF</p>
            </div>

            <div class="weights-panel">
                <h2>2. Weights & Bias (Dials)</h2>
                <div id="weightsControls">
                    <!-- Weight sliders will be added by JS -->
                </div>
                 <div class="weight-control">
                    <label for="biasSlider">Bias:</label>
                    <input type="range" id="biasSlider" min="-5" max="5" value="0" step="0.1" oninput="updateCalculationsAndVisuals()">
                    <span class="weight-value" id="biasValue">0.0</span>
                </div>
            </div>

            <div class="network-panel">
                <h2>3. The Neuron at Work</h2>
                <div class="network-visualization">
                    <!-- Visual inputs on the left, output neuron on the right -->
                    <div id="input-dots-container" style="display: flex; flex-direction: column; justify-content: space-around; height: 160px; margin-right: 50px;">
                         <!-- Placeholder for input dots, will align with SVG connection start points -->
                    </div>
                    <div class="neuron-vis" id="output-neuron-vis">
                        <div class="label">Output</div>
                        <div class="value">Sum: 0<br>Act: 0</div>
                    </div>
                    <svg class="connections-svg" id="connectionsSvg"></svg>
                </div>
                <div class="calculation-display" id="calculationDisplay">
                    Weighted Sum: (I1*W1) + (I2*W2) + (I3*W3) + (I4*W4) + Bias = 0
                </div>
            </div>
        </div>
        
        <div class="output-display">
            Neuron's Answer: <span id="finalOutputActivation">0.500</span>
            (<span class="prediction" id="finalOutputPrediction">Maybe?</span>)
        </div>

        <div class="controls">
            <button id="runButton" onclick="runAnimatedForwardPass()">Run Brain!</button>
        </div>

        <div class="info-box">
            <strong>How it "Thinks" (when you press "Run Brain!"):</strong>
            <ol>
                <li>The Neuron gets values (0 or 1) from each Input square.</li>
                <li>Animated dots show the "message strength" (Input * Weight) travelling to the Output Neuron. Brighter/bigger dots mean stronger messages!</li>
                <li>The Neuron calculates a <strong>Weighted Sum</strong>: (Input1*Weight1) + (Input2*Weight2) + ... + Bias.</li>
                <li>It uses a "squisher" function (Sigmoid) on this sum to get its <strong>Activation</strong> (a number from 0 to 1). Close to 1 means "YES!", close to 0 means "NO!".</li>
            </ol>
            <p><strong>Your Challenge:</strong> Adjust the weights and bias sliders. Can you "teach" the neuron to correctly recognize the target pattern (Top row: 1,1; Bottom row: 0,0)? A good setting might make the output activation > 0.9 for the target and < 0.1 for others.</p>
        </div>

    </div>

    <script>
        const NUM_INPUTS = 4; // 2x2 grid
        const ANIMATION_DURATION = 800; // ms for dot travel
        const PULSE_DURATION = 600; // ms for neuron pulse

        // DOM Elements
        const dom = {
            inputGrid: document.getElementById('inputGrid'),
            weightsControls: document.getElementById('weightsControls'),
            biasSlider: document.getElementById('biasSlider'),
            biasValue: document.getElementById('biasValue'),
            outputNeuronVis: document.getElementById('output-neuron-vis'),
            connectionsSvg: document.getElementById('connectionsSvg'),
            calculationDisplay: document.getElementById('calculationDisplay'),
            finalOutputActivation: document.getElementById('finalOutputActivation'),
            finalOutputPrediction: document.getElementById('finalOutputPrediction'),
            runButton: document.getElementById('runButton'),
            inputDotsContainer: document.getElementById('input-dots-container')
        };

        let inputValues = [0, 0, 0, 0];
        let weights = [0, 0, 0, 0]; // Initial weights
        let bias = 0;

        // Suggested "trained" weights for "Top ON, Bottom OFF" (1,1,0,0)
        const trainedWeights = [2.5, 2.5, -2.5, -2.5];
        const trainedBias = -2;

        // --- Sigmoid Function ---
        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }

        // --- Setup UI ---
        function setupUI() {
            // Input Grid
            for (let i = 0; i < NUM_INPUTS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('input-cell');
                cell.dataset.index = i;
                cell.textContent = `I${i+1}: 0`;
                cell.onclick = toggleInput;
                dom.inputGrid.appendChild(cell);

                // Input dots for visualization
                const dotPlaceholder = document.createElement('div');
                dotPlaceholder.id = `input-dot-placeholder-${i}`;
                dotPlaceholder.classList.add('neuron-vis', 'neuron-input-vis'); // Style like a neuron
                dotPlaceholder.style.width = '30px'; dotPlaceholder.style.height = '30px';
                dotPlaceholder.style.fontSize = '0.7em';
                dotPlaceholder.innerHTML = `I${i+1}`;
                dom.inputDotsContainer.appendChild(dotPlaceholder);


                // Weight Sliders
                const weightCtrl = document.createElement('div');
                weightCtrl.classList.add('weight-control');
                weightCtrl.innerHTML = `
                    <label for="w${i}Slider">Weight W${i+1}:</label>
                    <input type="range" id="w${i}Slider" min="-5" max="5" value="${weights[i]}" step="0.1" data-index="${i}">
                    <span class="weight-value" id="w${i}Value">${weights[i].toFixed(1)}</span>
                `;
                dom.weightsControls.appendChild(weightCtrl);
                document.getElementById(`w${i}Slider`).oninput = updateWeight;
            }
            dom.biasSlider.oninput = updateBias;
            updateBias(); // Initialize bias display
        }

        function toggleInput(event) {
            const index = parseInt(event.target.dataset.index);
            inputValues[index] = inputValues[index] === 0 ? 1 : 0;
            event.target.textContent = `I${index+1}: ${inputValues[index]}`;
            event.target.classList.toggle('active', inputValues[index] === 1);
            updateCalculationsAndVisuals();
        }

        function updateWeight(event) {
            const index = parseInt(event.target.dataset.index);
            weights[index] = parseFloat(event.target.value);
            document.getElementById(`w${index}Value`).textContent = weights[index].toFixed(1);
            updateCalculationsAndVisuals();
        }

        function updateBias() {
            bias = parseFloat(dom.biasSlider.value);
            dom.biasValue.textContent = bias.toFixed(1);
            updateCalculationsAndVisuals();
        }
        
        // --- Drawing Connections ---
        let inputDotPositions = [];
        let outputNeuronPosition;

        function getElementCenter(el) {
            const rect = el.getBoundingClientRect();
            const svgRect = dom.connectionsSvg.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2 - svgRect.left,
                y: rect.top + rect.height / 2 - svgRect.top,
            };
        }

        function drawConnections() {
            dom.connectionsSvg.innerHTML = ''; // Clear existing
            outputNeuronPosition = getElementCenter(dom.outputNeuronVis);
            inputDotPositions = [];

            for (let i = 0; i < NUM_INPUTS; i++) {
                const inputPlaceholder = document.getElementById(`input-dot-placeholder-${i}`);
                inputDotPositions[i] = getElementCenter(inputPlaceholder);

                // Line
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute('x1', inputDotPositions[i].x);
                line.setAttribute('y1', inputDotPositions[i].y);
                line.setAttribute('x2', outputNeuronPosition.x);
                line.setAttribute('y2', outputNeuronPosition.y);
                line.classList.add('connection-line');
                line.id = `line-i${i}-out`;
                dom.connectionsSvg.appendChild(line);

                // Weight display on line
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', (inputDotPositions[i].x + outputNeuronPosition.x) / 2 - 15);
                text.setAttribute('y', (inputDotPositions[i].y + outputNeuronPosition.y) / 2 - 5);
                text.classList.add('weight-display-svg');
                text.id = `weight-text-i${i}`;
                text.textContent = `W${i+1}=${weights[i].toFixed(1)}`;
                dom.connectionsSvg.appendChild(text);

                // Animated dot (initially hidden)
                const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                dot.id = `dot-i${i}-out`;
                dot.setAttribute('cx', inputDotPositions[i].x);
                dot.setAttribute('cy', inputDotPositions[i].y);
                dot.classList.add('anim-dot');
                dom.connectionsSvg.appendChild(dot);
            }
            // Bias "connection" (conceptual)
            const biasText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            biasText.setAttribute('x', outputNeuronPosition.x);
            biasText.setAttribute('y', outputNeuronPosition.y + 55); // Below neuron
            biasText.classList.add('weight-display-svg');
            biasText.id = 'bias-text-svg';
            biasText.textContent = `Bias=${bias.toFixed(1)}`;
            dom.connectionsSvg.appendChild(biasText);

            // Update dynamic weight text on lines
            for (let i = 0; i < NUM_INPUTS; i++) {
                const weightTextEl = document.getElementById(`weight-text-i${i}`);
                if (weightTextEl) weightTextEl.textContent = `W${i+1}=${weights[i].toFixed(1)}`;
            }
            const biasTextEl = document.getElementById('bias-text-svg');
            if (biasTextEl) biasTextEl.textContent = `Bias=${bias.toFixed(1)}`;
        }

        // --- Calculations and Visual Updates (No Animation) ---
        function calculateForwardPass() {
            let weightedSum = bias;
            let calcString = `Bias (${bias.toFixed(1)})`;

            for (let i = 0; i < NUM_INPUTS; i++) {
                weightedSum += inputValues[i] * weights[i];
                calcString += ` + (I${i+1}[${inputValues[i]}] * W${i+1}[${weights[i].toFixed(1)}])`;
            }
            calcString += ` = ${weightedSum.toFixed(2)}`;
            
            const activation = sigmoid(weightedSum);
            return { weightedSum, activation, calcString };
        }
        
        function updateCalculationsAndVisuals() {
            const { weightedSum, activation, calcString } = calculateForwardPass();

            dom.outputNeuronVis.innerHTML = `
                <div class="label">Output</div>
                <div class="value">Sum: ${weightedSum.toFixed(2)}<br>Act: ${activation.toFixed(3)}</div>`;
            dom.calculationDisplay.textContent = `Weighted Sum: ${calcString}`;
            dom.finalOutputActivation.textContent = activation.toFixed(3);

            if (activation > 0.7) { // Threshold for "YES"
                dom.finalOutputPrediction.textContent = "YES!";
                dom.finalOutputPrediction.className = "prediction yes";
                dom.outputNeuronVis.style.backgroundColor = '#81c784'; // Brighter green for YES
            } else if (activation < 0.3) { // Threshold for "NO"
                dom.finalOutputPrediction.textContent = "NO!";
                dom.finalOutputPrediction.className = "prediction no";
                 dom.outputNeuronVis.style.backgroundColor = '#e57373'; // Brighter red for NO
            } else {
                dom.finalOutputPrediction.textContent = "Maybe?";
                dom.finalOutputPrediction.className = "prediction";
                dom.outputNeuronVis.style.backgroundColor = '#ffc107'; // Amber for neutral
            }
            drawConnections(); // Redraw connections to update weight text
        }

        // --- Animation ---
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        async function pulseNeuron(neuronEl) {
            neuronEl.classList.add('pulsing');
            await sleep(PULSE_DURATION);
            neuronEl.classList.remove('pulsing');
        }

        async function animateSignal(inputId) {
            const dot = document.getElementById(`dot-i${inputId}-out`);
            if (!dot || inputValues[inputId] === 0) { // Only animate if input is ON
                if (dot) dot.style.opacity = 0;
                return;
            }

            const startPos = inputDotPositions[inputId];
            const endPos = outputNeuronPosition;
            const weightAbs = Math.abs(weights[inputId]);
            
            // Visual feedback for strength: dot size and color intensity
            dot.setAttribute('r', 3 + weightAbs * 1.5); // Base radius 3, grows with weight
            dot.style.fill = weights[inputId] >= 0 ? '#4caf50' : '#f44336'; // Green for positive, red for negative weight influence
            dot.style.opacity = 0.5 + Math.min(0.5, weightAbs / 5); // Opacity based on weight strength

            let startTime = null;
            function animationStep(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / ANIMATION_DURATION, 1);
                dot.setAttribute('cx', startPos.x + (endPos.x - startPos.x) * progress);
                dot.setAttribute('cy', startPos.y + (endPos.y - startPos.y) * progress);
                if (progress < 1) requestAnimationFrame(animationStep);
                else { dot.style.opacity = 0; } // Hide after travel
            }
             return new Promise(resolve => {
                requestAnimationFrame(function(timestamp) {
                    startTime = timestamp; // Reset start time for this animation
                    requestAnimationFrame(function step(ts) {
                        const progress = Math.min((ts - startTime) / ANIMATION_DURATION, 1);
                        dot.setAttribute('cx', startPos.x + (endPos.x - startPos.x) * progress);
                        dot.setAttribute('cy', startPos.y + (endPos.y - startPos.y) * progress);
                        if (progress < 1) requestAnimationFrame(step);
                        else { dot.style.opacity = 0; resolve(); }
                    });
                });
            });
        }
        
        let isAnimating = false;
        async function runAnimatedForwardPass() {
            if (isAnimating) return;
            isAnimating = true;
            dom.runButton.disabled = true;

            // Highlight active inputs briefly
            const inputPromises = [];
            for (let i = 0; i < NUM_INPUTS; i++) {
                if (inputValues[i] === 1) {
                    const inputVis = document.getElementById(`input-dot-placeholder-${i}`);
                    if(inputVis) inputPromises.push(pulseNeuron(inputVis));
                }
            }
            if (inputPromises.length > 0) await Promise.all(inputPromises);
            else await sleep(PULSE_DURATION/2); // Small pause even if no inputs are on

            // Animate signals from inputs to output
            const signalAnimations = [];
            for (let i = 0; i < NUM_INPUTS; i++) {
                 if (inputValues[i] === 1) { // Only animate if input is ON
                    signalAnimations.push(animateSignal(i));
                 }
            }
            if(signalAnimations.length > 0) await Promise.all(signalAnimations);
            else await sleep(ANIMATION_DURATION/2); // Pause if no signals

            // Recalculate (already done by input/weight changes, but ensures consistency)
            // and update visuals (this also pulses the output neuron now)
            updateCalculationsAndVisuals(); // This updates the text and color
            await pulseNeuron(dom.outputNeuronVis); // Explicitly pulse output neuron
            
            isAnimating = false;
            dom.runButton.disabled = false;
        }


        // --- Initialization ---
        window.onload = () => {
            setupUI();
            // Optional: Start with "trained" weights or encourage user to find them
             for (let i = 0; i < NUM_INPUTS; i++) {
                 document.getElementById(`w${i}Slider`).value = trainedWeights[i];
                 weights[i] = trainedWeights[i]; // Also update the actual weight variable
                 document.getElementById(`w${i}Value`).textContent = weights[i].toFixed(1);
             }
             dom.biasSlider.value = trainedBias;
             bias = trainedBias; // Update bias variable
             dom.biasValue.textContent = bias.toFixed(1);

            updateCalculationsAndVisuals(); // Initial calculation and drawing
        };
        window.onresize = () => {
            updateCalculationsAndVisuals(); // Redraw everything on resize
        };

    </script>
</body>
</html>